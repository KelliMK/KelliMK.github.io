<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Dry Blob's Probs</title>
</head>
<style></style>
<script src="pixi/pixi.min.js"></script>
<script src="pixi/spriteUtilities.js"></script>
<script src="pixi/dust.js"></script>
<body>
  <div id="fuck">
    <script type="text/javascript">
    // Add new texts for shit and keep going with the book!!
    // Aliases
    let Application = PIXI.Application;
    let Container = PIXI.Container;
    let dust = new Dust(PIXI);
    let Graphics = PIXI.Graphics;
    let loader = PIXI.loader;
    let MovieClip = PIXI.extras.MovieClip;
    let resources = PIXI.loader.resources;
    let Sprite = PIXI.Sprite;
    let su = new SpriteUtilities(PIXI);
    let Text = PIXI.Text;
    let TextStyle = PIXI.TextStyle;
    let TextureCache = PIXI.utils.TextureCache;

    //Create a Pixi Application
    let app = new Application({
      width: 512,
      height: 512,
      antialias: true,
      transparent: false,
      resolution: 1
    });

    //Add the canvas that Pixi automatically created for you to the HTML document
    document.body.appendChild(app.view);

    loader
    .add("img/genericOverWorld.json")
    .load(setup);
    console.log(PIXI.loader.resources);

    // Setup object variables that will be used by other functions
    let arena, blob, blobs, currentBlobs, door, exit, explorer, fountain,
    textScene, gameScene, id, player, state;

    // Setup text variables
    let continueMessage, message1, message2, message3, message4, message5,
    message6, message7, message8, message9, message10, style1, style2, style3,
    style4;

    let iteration = 1;

    let initialBlobs = 8;
    let holdingBlob = false;

    // Capture the WSAD keys for player direction
    let up = keyboard("w"),
    down = keyboard("s"),
    right = keyboard("d"),
    left = keyboard("a"),
    enter = keyboard("Enter");

    // Movement vector
    let movement = [0, 0];

    function setup() {

      // Create the 'gameScene' group
      gameScene = new Container();
      app.stage.addChild(gameScene);

      // Create the 'textScene' group
      textScene = new Container();
      textScene.visible = false;
      app.stage.addChild(textScene);

      // Make the sprites and add them to the 'gameScene'
      // Create an alias for the texture atlas frame ids
      id = resources["img/genericOverWorld.json"].textures;

      // Arena
      arena = new Sprite(id["islandArena.png"]);
      gameScene.addChild(arena);

      // door
      let doorFrameArray = [
        id["trapDoorClosed.png"],
        id["trapDoorOpen.png"]
      ]
      door = su.sprite(doorFrameArray);
      door.states = {
        closed: 0,
        open: 1
      }
      door.show(door.states.closed);
      door.position.set(32, 16);
      gameScene.addChild(door);

      // Create the 'Fountain' Sprite
      let fountainFrames = [
        id["fountainOne.png"],
        id["fountainTwo.png"],
        id["fountainThree.png"]
      ];
      fountain = new MovieClip(fountainFrames);
      fountain.x = gameScene.width - fountain.width - 20;
      fountain.y = gameScene.height - fountain.height - 20;
      fountain.play();
      fountain.animationSpeed = 0.125;
      gameScene.addChild(fountain);

      // Explorer
      let explorerFrameArray = [
        id["playerWalkNorthOne.png"], // 0
        id["playerIdleNorth.png"],    // 1
        id["playerWalkNorthTwo.png"], // 2
        id["playerIdleNorth.png"],    // 3
        id["playerWalkEastOne.png"],  // 4
        id["playerIdleEast.png"],     // 5
        id["playerWalkEastTwo.png"],  // 6
        id["playerIdleEast.png"],     // 7
        id["playerWalkWestOne.png"],  // 8
        id["playerIdleWest.png"],     // 9
        id["playerWalkWestTwo.png"],  // 10
        id["playerIdleWest.png"],     // 11
        id["playerWalkSouthOne.png"], // 12
        id["playerIdleSouth.png"],    // 13
        id["playerWalkSouthTwo.png"], // 14
        id["playerIdleSouth.png"]     // 15
      ];
      explorer = su.sprite(explorerFrameArray);
      explorer.states = {
        up: 1,
        right: 5,
        left: 9,
        down: 13,
        walkUp: [0, 3],
        walkRight: [4, 7],
        walkLeft: [8, 11],
        walkDown: [12, 15]
      }
      explorer.show(explorer.states.down);
      explorer.x = 80;
      explorer.y = gameScene.height / 2 - explorer.height / 2;
      explorer.vx = 0;
      explorer.vy = 0;
      explorer.fps = 12;
      gameScene.addChild(explorer);

      // Create blobs
      currentBlobs = initialBlobs;
      let spacing = 50;
      let xOffset = 60;

      // An array to store all the blob cuties
      blobs = [];

      // Make as many blobs as there are 'numberOfBlobs'
      for (let i = 0; i < initialBlobs; i++) {

        // Make a blob
        blob = new Sprite(id["blobIdleOne.png"]);
        let x = spacing * i + xOffset;
        let y = randomInt(0, app.stage.height - blob.height);

        // Set the blob's positions
        blob.x = x;
        blob.y = y;

        blobs.push(blob);

        gameScene.addChild(blob);
      }

      //Left arrow key `press` method
      left.press = function() {
        explorer.playAnimation(explorer.states.walkLeft);
        if (holdingBlob == false) {
          explorer.vx = -(2 / iteration);
          explorer.vy = 0;
        } else if (holdingBlob == true) {
          explorer.vx = -(1 / iteration);
          explorer.vy = 0;
        }
      };

      //Left arrow key `release` method
      left.release = function() {

        //If the left arrow has been released, and the right arrow isn't down,
        //and the explorer isn't moving vertically:
        //Stop the explorer
        if (!right.isDown && explorer.vy === 0) {
          explorer.show(explorer.states.left);
          explorer.vx = 0;
        }
      };

      //Up
      up.press = function() {
        explorer.playAnimation(explorer.states.walkUp);
        if (holdingBlob == false) {
          explorer.vx = 0;
          explorer.vy = -(2 / iteration);
        } else if (holdingBlob == true) {
          explorer.vx = 0;
          explorer.vy = -(1 / iteration);
        }
      };
      up.release = function() {
        if (!down.isDown && explorer.vx === 0) {
          explorer.show(explorer.states.up);
          explorer.vy = 0;
        }
      };

      //Right
      right.press = () => {
        explorer.playAnimation(explorer.states.walkRight);
        if (holdingBlob == false) {
          explorer.vx = (2 / iteration);
          explorer.vy = 0;
        } else if (holdingBlob == true) {
          explorer.vx = (1 / iteration);
          explorer.vy = 0;
        }
      };
      right.release = () => {
        if (!left.isDown && explorer.vy === 0) {
          explorer.show(explorer.states.right);
          explorer.vx = 0;
        }
      };

      //Down
      down.press = function() {
        explorer.playAnimation(explorer.states.walkDown);
        if (holdingBlob == false) {
          explorer.vx = 0;
          explorer.vy = (2 / iteration);
        } else if (holdingBlob == true) {
          explorer.vx = 0;
          explorer.vy = (1 / iteration);
        }
      };
      down.release = function() {
        if (!up.isDown && explorer.vx === 0) {
          explorer.show(explorer.states.down);
          explorer.vy = 0;
        }
      };

      // Enter
      enter.press = function() {
        if (textScene.visible === true && gameScene.visible === false) {
          explorer.vx = 0;
          explorer.vy = 0;
          runSetup();
        }
      };

      // Create the game over scenes
      textScene = new Container();
      app.stage.addChild(textScene);
      textScene.visible = false;

      // Define each text style
      style1 = new TextStyle({
        fontFamily: "Futura",
        fontSize: 36,
        fill: "white"
      });

      style2 = new TextStyle({
        fontFamily: "Georgia, serif",
        fontSize: 48,
        fill: "white"
      });

      style3 = new TextStyle({
        fontFamily: "Verdana",
        fontSize: 16,
        fill: "white"
      });

      style4 = new TextStyle({
        fontFamily: "\"Trebuchet MS\", Helvetica, sans-serif",
        fontSize: 16,
        fill: "red",
        fontVariant: "small-caps",
        fontWeight: "bold"
      });

      // create the sprite and add it to the game over scene
      continueMessage = new Text("Press \"Enter\" to keep going.", style4);
      continueMessage.anchor.x = 0.5;
      continueMessage.anchor.y = 0.5;
      continueMessage.x = app.stage.width / 2;
      continueMessage.y = app.stage.height - continueMessage.height;
      textScene.addChild(continueMessage);

      placeText();

      // Set the game state to play
      state = play;
      app.ticker.add(delta => gameLoop(delta));
    }

    function runSetup(){
      ++iteration;
      //gameScene.destroy({children:true, texture:true, baseTexture:true});
      //textScene.destroy({children:true, texture:true, baseTexture:true});
      setup();
    }

    function randomInt(min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    function gameLoop(delta){

      // Update the current game state:
      state(delta);
      dust.update();
    }

    function play(delta) {


      // use the explorer's velocity to make it move
      explorer.x += explorer.vx;
      explorer.y += explorer.vy;

      // Contain the explorer inside the area of the dungeonTexture
      contain(explorer, {x: 8, y: 8, width: 500, height: 500});

      blobs.forEach(function(blob) {
        // Hit test for picking up blobs
        if(hitTestRectangle(explorer, blob)) {
          holdingBlob = true;
          blob.x = explorer.x + 4;
          blob.y = explorer.y + 4;
        } else {
          holdingBlob = false;
        }
        // Hit test for putting blobs in the fountains
        if(hitTestRectangle(explorer, fountain) && holdingBlob == true) {
          blob.x = explorer.x + 4000;
          blob.y = explorer.y + 4000;
          holdingBlob = false;
          currentBlobs = currentBlobs - 1;
          gameScene.removeChild(blob);
        }
      })
      if(currentBlobs <= 0) {
        door.show(door.states.open);
      }
      if(hitTestRectangle(explorer, door) && currentBlobs <= 0) {
        TextState();
      }
    }

    function placeText() {
        message1 = new Text("Success! You helped the blobs out!", style1);
        message1.anchor.x = 0.5;
        message1.anchor.y = 0.5;
        message1.x = app.stage.width / 2;
        message1.y = app.stage.height / 2;
        textScene.addChild(message1);
    }

    function TextState() {
      gameScene.visible = false;
      textScene.visible = true;
    }

    function keyboard(value) {
      let key = {};
      key.value = value;
      key.isDown = false;
      key.isUp = true;
      key.press = undefined;
      key.release = undefined;
      //The `downHandler`
      key.downHandler = event => {
        if (event.key === key.value) {
          if (key.isUp && key.press) key.press();
          key.isDown = true;
          key.isUp = false;
          event.preventDefault();
        }
      };

      //The `upHandler`
      key.upHandler = event => {
        if (event.key === key.value) {
          if (key.isDown && key.release) key.release();
          key.isDown = false;
          key.isUp = true;
          event.preventDefault();
        }
      };

      //Attach event listeners
      const downListener = key.downHandler.bind(key);
      const upListener = key.upHandler.bind(key);

      window.addEventListener(
        "keydown", downListener, false
      );
      window.addEventListener(
        "keyup", upListener, false
      );

      // Detach event listeners
      key.unsubscribe = () => {
        window.removeEventListener("keydown", downListener);
        window.removeEventListener("keyup", upListener);
      };

      return key;
    }

    function contain(sprite, container) {

      let collision = undefined;

      //Left
      if (sprite.x < container.x) {
        sprite.x = container.x;
        collision = "left";
      }

      //Top
      if (sprite.y < container.y) {
        sprite.y = container.y;
        collision = "top";
      }

      //Right
      if (sprite.x + sprite.width > container.width) {
        sprite.x = container.width - sprite.width;
        collision = "right";
      }

      //Bottom
      if (sprite.y + sprite.height > container.height) {
        sprite.y = container.height - sprite.height;
        collision = "bottom";
      }

      //Return the `collision` value
      return collision;
    }

    //The `hitTestRectangle` function
    function hitTestRectangle(r1, r2) {

      //Define the variables we'll need to calculate
      let hit, combinedHalfWidths, combinedHalfHeights, vx, vy;

      //hit will determine whether there's a collision
      hit = false;

      //Find the center points of each sprite
      r1.centerX = r1.x + r1.width / 2;
      r1.centerY = r1.y + r1.height / 2;
      r2.centerX = r2.x + r2.width / 2;
      r2.centerY = r2.y + r2.height / 2;

      //Find the half-widths and half-heights of each sprite
      r1.halfWidth = r1.width / 2;
      r1.halfHeight = r1.height / 2;
      r2.halfWidth = r2.width / 2;
      r2.halfHeight = r2.height / 2;

      //Calculate the distance vector between the sprites
      vx = r1.centerX - r2.centerX;
      vy = r1.centerY - r2.centerY;

      //Figure out the combined half-widths and half-heights
      combinedHalfWidths = r1.halfWidth + r2.halfWidth;
      combinedHalfHeights = r1.halfHeight + r2.halfHeight;

      //Check for a collision on the x axis
      if (Math.abs(vx) < combinedHalfWidths) {

        //A collision might be occuring. Check for a collision on the y axis
        if (Math.abs(vy) < combinedHalfHeights) {

          //There's definitely a collision happening
          hit = true;
        } else {

          //There's no collision on the y axis
          hit = false;
        }
      } else {

        //There's no collision on the x axis
        hit = false;
      }

      //`hit` will be either `true` or `false`
      return hit;
    };
    </script>
  </div>
</body>
</html>
